# Verilog 注意事项

## `1.` 分位赋值

`A.` 语法格式

```js
assign O1 [7:0] = A [31:24] ;
assign O1 = A [31:24] ;
```

`B.` 信号方向

+ 信号定义好之后，其不仅决定了位宽还决定了方向，例如定义为[4:7]的b信号，四个管脚分别为4，5，6，7，在使用中只能正向接，不能反向接，因此接b[4:7]是合法的，而b[7:4]是不合法的；同理接c[8:11]是合法的，接c[11:8]是不合法的。

## `2.` `assign`

+ 组合逻辑使用 `assign` 与 三目运算符 对output进行赋值，避免在always语句中出现组合逻辑使用阻塞赋值。

```js
assign C = (ALUOp == 3'b000) ?                     A + B :             
           (ALUOp == 3'b001) ?                     A - B :
           (ALUOp == 3'b010) ?                     A & B :
           (ALUOp == 3'b011) ?                     A | B :
           (ALUOp == 3'b100) ?                    A >> B :
           (ALUOp == 3'b101) ? $signed($signed(A) >>> B) : 32'h0000_0000 ;
```

## `3.` `>>>`的使用

+ 在Verilog HDL中，`wire`、`reg`等数据类型默认都是 * 无符号 * 的。当你希望做符号数的操作时，你需要使用 `$signed()` 。
+ 但是如果表达式中同时存在符号数和无符号数, 符号数会默认转换为无符号数, 如 `a > $signed(b)` 等价于 `a > b` (`$signed()` 失效) 。
+ 对于移位运算符, 其右侧的操作数总是被视为无符号数, 并且不会对运算结果的符号产生影响.

```js
$signed($signed(A) >>> B)
```

## `4.` 数字字面量

+ 数字字面量格式为 `<位宽>'<进制><值>`, 如 `10'd100`.
+ 省略位宽时采用默认位宽 (32bit), 省略进制时默认采用十进制, 如 `10` == `32'b1010`.
+ 变量的位可以使用 `x` 和 `z`. `x` 为不定值, `z` (也可以写成 `?`) 为高阻态. 如 `4'b10x0`, `8'h4?`.
+ 对于负数, 负号要写在字面量整体前, 如 `-8'd5`.
+ 值之间可以用下划线提高可读性, 如 `8'b0011_1010`, 不可以放在进制和值之间.
+ 字符串可以表示为数字字面量, 如 `"AB"` == `16'h4142`. 存入寄存器时, 字符串被存放在低位, 同时高位用 0 填充.

## `5.` `case`语法

```js
case(data)
    0: out <= 4;
    1: out <= 5;
    2: out <= 2;
    3: begin
        out <= 1;
    end
    default: ;
endcase
```

## `6.` 时序逻辑相关

### `always` 块

* 若 `always` 之后紧跟 `@(...)`, 表示当括号中的条件满足时，将会执行 `always`, 用于时序逻辑 (`posedge` 表示上升沿, `negedge` 表示下降沿, 默认为都敏感, 多个条件用 `,` 或 `or` 隔开, 当一个触发时就执行)
* 若 `always` 之后紧跟 `@*` 或 `@(*)`, 表示当紧跟语句中信号变化时，将会执行 `always`, 一般与 `reg` 型和阻塞赋值配合使用, 用于组合逻辑
* 若 `always` 之后紧跟语句, 表示当反复执行, 一般用来产生周期信号

```js
always @(posedge clk) // clk 到达上升沿触发
always @(a)

always @(*)

always #10
```

* 两个 always 语句如果同时触发就会产生竞争, 触发的先后顺序不确定.
* 并且多个 always 语句间是并行执行的.

### `initial` 块

* `initial` 一般用来初始化 `reg` 型, 是 *不可综合* 的!

```js 
initial begin
    mem = 0;
end
```

### 寄存器

* 可复位的寄存器分为 *同步复位寄存器* 和 *异步复位寄存器* .

```js
module flopr(input clk
             input reset,
             input [3:0] d,
             output [3:0] q);
    // asynchronous reset
    always @(posedge clk, posedge reset)
        if (reset) q<= 4'b0;
        else q <= d;
endmodule
```

```js
module flopr(input clk
             input reset,
             input [3:0] d,
             output [3:0] q);
    // synchronous reset
    always @(posedge clk)
        if (reset) q<= 4'b0;
        else q <= d;
endmodule
```

```js
// 使能复位寄存器
module flopr(input clk
             input reset,
             input en,
             input [3:0] d,
             output [3:0] q);
    // synchronous reset
    always @(posedge clk)
        if (reset) q <= 4'b0;
        else if(en) q <= d;
endmodule
```
## `7.` 搭建状态机
### ** 务必记得给 `state` * 定义位数 * 并 * 赋初值 * ！！！
### ** 状态机 `one-hot` 编码
### ** 有关`reg`初始化记得定义位数这件事我已经说倦了，但是做起题来还是会屡屡在这里翻车 。。。

``` js
reg [3:0] state = s0;
```

### ** `parameter` 型变量定义时两两之间用 `,`

``` js
parameter  s0 = 4'b0001,
           s1 = 4'b0010,
           s2 = 4'b0100,
           s3 = 4'b1000;
```
### ** 不用 `OutputReg`，直接在 `always` 语句外对 `Output` 使用 `assign` 语句利用 * 组合逻辑 * 赋值

``` js
assign zo = (state == `S4); // Moore
assign zo = (state == `S3) & (data == 1'b0); // Mealy 
```
### ** 对于稍显复杂的情况，譬如 `Blockchecker` 一题，出现最终输出并不仅仅由 `state` / `state` + `input` 决定的情况下，可以使用 `Register`，记录输出条件。但需要注意的两点是：
+ `Register` 相关操作在 `switch` 对应支路语句中完成。
+ `Register` 初始化与 `state Register` 一样，一定一定，一定一定，一定一定要记得 **定义位数** 。

## `8.` 多个状态机的使用
### ** 在同一条分支语句中，对同一个寄存器进行多次 `非阻塞赋值` 时，`Isim` 仿真最终结果以最后一次为准。

## `9.` 关于代码可综合问题，重点关注以下几点：
+ 不要用 `initial` 块、不要为寄存器赋初值
  `initial` 块用于在仿真开始时对寄存器进行初始化、执行其他代码。**在综合时，`initial` 块会被忽略** ，不起任何作用，且 **为 `reg` 指定的初始值也会被忽略** 。也就是说，如下的代码都是不起作用的。

    ``` js
    reg v = 6; // 综合时，初始值被忽略
  
    reg m;
    initial begin
        m = 1; // 综合时，initial 块被忽略
    end
    ```
    如果你想在模块开始运行时，对寄存器进行一些初始化，请使用 `reset` 信号控制复位，并在 Testbench 开始的部分提供一个 `reset` 信号。例如，上面的代码正确写法为：

    ``` js
    always @(posedge clk) begin
        if (reset) begin
            v <= 6;
            m <= 1;
        end
    end
    ```
    Testbench 正确的写法：

    ``` js
    reg clk = 0;
    reg reset = 0; // 只有在tb中可以直接赋初值
    always #5 clk = ~ clk; // 创建周期为10的时钟
    initial begin
        reset = 1
        # 10 // 延时一个时钟周期
        reset = 0;
        // 接下来开始你的测试
    end
    ```
## `10.` `<=` 非阻塞赋值的使用
+ 在状态机书写中，`case` 语句中 `state <= s0` `register` 用到了非阻塞赋值
+ 在寄存器书写中，`if` 语句中 `Out <= In` `wire` 也可以直接使用非阻塞赋值

## 一周没有写 Verilog, 就靠着对自己能力的 `Blind Faith` 直接去参加 `P1` ，多少有点小慌。 考前还是总结复习一下，练练手吧。


## `15:36 ~ 17:30`
1. `P1` 课后再练一遍 **
2. `Isim` 新功能环境熟悉 **
3. `cscore` 最后一节copy下来阅读一遍
4. （ `roife` 注意事项 ）




## `P1` 考后反思：
### 总体来讲还算比较顺利，本次考试再一次让我意识到了考试时良好积极心态的重要性！！！
#### 第一题，被卡住了。
判断32位二进制数字各数位01个数的多少，因为考前看过一篇有关单目运算符的帖子，所以考试的时候也尝试着往这个方向考虑了一下，结果当然失败了。最后打表硬解(doge)
+ 注意：
  + 单目运算符的使用 （助教居然还提问了我这个问题，那我必然不会，凭借自己高明的手腕含糊其辞蒙混过关（笑哭））
  + always@( ... ) 中敏感信号的写法

#### 第二题，又被卡住了。（笑哭）
复杂，太复杂了。五个信号，无数种状态，此题充分展现了状态机合并的重要性。
但是，说他难吧，这道题真的并没有很难。题干中甚至给出了状态机的模样，直接将图片翻译成代码即可。
+ 注意
  + 严格按指令操作，一道阅读理解题

注：题干中对于异步复位的说法很不明确，这也是做题时困扰我的主要问题之一。但仔细想想，也没有什么好纠结的，题中状态机已经给出，复位当然指的就是回到图中原始的关机状态了~~~说到底，这还得赖我自己的悟性不够强。

#### 第三题，很简单。
判断复数，情况考虑周全就好，没什么好多说的。但实际上我第一次画状态机时，少考虑了 “(+/-)(2)i” 以及 “2 + i” 的情况，但由于此题中状态机的输入直接可以分为 "isdigit","ischar","isi","else" 四类，并且七个基本状态也已然相当明确，中途发现错误后随时修正不是一件难事。


### 心态！ 心态！ 心态！ 
### 重要的事情说三遍！
### （其实也并没有很重要）



### 带着必胜的决心走进考场；
### 抱着必死的勇气冷静作答；
### 以无所谓的态度面对挫折；
### 嘴角轻扬起微笑离开考场。

# Too young, too naive

