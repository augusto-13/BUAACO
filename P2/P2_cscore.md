# 内存操作
## 简介
​在高级语言中，我们可以使用多维数组对内存进行多维操作，但实际上，一般这些多维数组在内存中也只是按照一维的形式连续存储的。比如二维数组 arr[2][2]，它在内存中会占用4个单位的连续空间，分别保存 arr[0][0]、arr[0][1]、arr[1][0]、arr[1][1]。

​作为低级语言，汇编语言对内存只能进行一维操作。而为了实现多维操作，我们就需要使用一些技巧了，下面会进行举例分析。

## 样例分析
​比如我们要将 $0~255$ 依次赋给一个 $16*16$ 的矩阵，填充方式如下图 $4*4$ 矩阵的例子。

![图 1](../../images/d3a01b1c8bfb849abef6e90b4d48a0023eb8e1602b3fb8fd65a0f007ad863b61.png)  


使用高级语言的话只需要两个`for`循环嵌套，如下：

![图 2](../../images/c1d8a91077545ad76b01278b9478e8846982943333523281e9d7515c9ce175c4.png)  


​使用汇编语言的话，就需要分为三步：

+ 初始化数据

    ![图 3](../../images/839bc734e8dcbf0c6fac2aed61a960b419cdc9480cda3bbcaed623a28f9e4149.png)  


​`t0` 和 `t1` 是总的行列数，`s0` 和 `s1` 是当前赋值的行列数，`$t2`就是要赋的值。

+ 为一行矩阵赋值

    ![图 4](../../images/912d41efb3fddda2f61896c87273d88b60c676b3f63bfabe09fc4edaa5e5139b.png)  


​`19~23行` 为当前矩阵元素对应的内存赋值，`24,27行` 更新数据，`28行` 判断这一行矩阵是否已完全赋值。

+ 准备为下一行矩阵赋值

    ![图 5](../../images/0db27e20a75b2b8f8e3669c3bb6d1300332202e02ad35ad1cabede5c04fbc05a.png)  


​当一行矩阵已赋完值后，更新数据，然后重新跳回到 `loop` 处为下一行矩阵赋值，直到整个矩阵都赋完值。

## 补充：利用Macros简化二维数组的计算
​ 在 MIPS 教程部分，我们学习了如何使用 `macro` 宏定义一些操作来简化我们的 MIPS 程序，对于二维数组的相关计算，我们可以发现，计算数组中元素的地址是一个重复且固定的算法，因此，我们计划创建一个 `macro` 来代替这些语句，从而减少代码行数，增加可读性，以便出错后更好的调试代码。

![图 7](../../images/a1b714d6c7ef51e47c514cbdef4f9b16e22ff06cde75387884503ee73e9a2c6c.png)  


​ 上图就是我们关于计算地址的 `macro` 了，我们精心的设计保证了运算中只改变 `%dst` 所代表的寄存器，避免了 `macro` 内部不可见的修改其他寄存器的情况的发生。这种复用代码的思想类似于函数，但是一定注意 `macro` 的运用中易出现的如上所述的问题，希望同学们能够熟练运用，写出易懂的汇编代码来。