# 测试程序设计
## 程序设计要点
+ 首先，要明确 CPU 支持哪些指令，我们的测试程序中使用到的指令不能超出 **CPU 支持的范围**。
+ 对于测试程序而言，我们追求的并不是过程与结果有多么巧妙，我们的目的只有一个，那就是**全面**的测试每条指令。比如测试加法，我们就要把正正相加，负负相加，正负相加的情况都考虑到。
+ 在用 Mars 编写测试程序时，对于一些伪指或看起来合法（但其实不合法，比如立即数溢出）的指令，MARS 会自动将其拆解转换成若干条基本指令，这样就违背了设计的初衷，如下图。所以将代码导入到 CPU 中测试之前，一定要注意下这个问题。

![图 1](../../images/8f825f1436170a585d17082e888c4215cf26b10f461b885e4397ab13a4c37aac.png)  


## 测试样例
假设我们已经设计好了一个 CPU 程序，它支持 `ori`, `lui`, `add`, `lw`, `sw`, `beq` 这些指令，现在我们要写个测试程序来测试我们 CPU 程序的正确性(**暂不考虑延迟槽**)。

## 测试程序从哪条指令开始呢
首先我们必须要知道，测试程序的第一步一定是测试**最基本**的指令，只有基本指令正确了，我们才可以测试更复杂的指令。这些最基本的指令一般都是在测试时能够不依赖其他类型的指令就能判断指令正确性的指令，比如 `ori`、`lui`、`addi` 等。

比如这里，我们要先测 `ori` 和 `lui` 指令，因为其他指令都得靠这两条指令为寄存器赋值，然后才能测试，不然寄存器的值都是 0，无法进行测试。

## ORI 指令
![图 2](../../images/bbd227d7cb1a15e692aedbd33e8485195c40dc5cbfdef822fedbf4550e823db1.png)  


第一条我们先测最基本的，与 0 进行 or 运算，然后第二条再测试两个非 0 数直接的 or 运算。从指令集的解释中，我们知道，`ori` 指令的第三个立即数参数是无符号扩展，所以就不存在负数的情况。

## LUI 指令
![图 3](../../images/73ccb49ce383da6a563099ddf0b02f4676ae0bc9cf450494084bae4e53d5b851.png)  


根据指令集对 `lui` 的介绍，其实我们只有测第一条指令就行了，后面两条指令是为了使用 `ori` 和 `lui` 这两条指令**构造一个负数**，用于后面 `add` 指令的测试。

## ADD 指令
![图 4](../../images/72acc70a95e2572f2edc7e3567f8c0e142119641310820fc9a7927a0cb6a90f5.png)  

对于 `add` 指令，我们利用之前 `ori` 和 `lui` 准备好的寄存器进行这三种情况的测试。

## SW 指令
![图 5](../../images/ccdbcefa2fff01a43bf2c3d8eb30ff10895d23e0933468e189cc7372e4febea3.png)  


对于 `sw` 和 `lw` 指令，我们得先测 `sw` 往内存中存数据，这样才能通过 `lw` 取数据，不然内存中数据都是 0，`lw` 指令对不对我们也看不出来。

这里我用了这么多 `sw` 指令，主要是为了把之前的数据先保存下来，**释放寄存器**。

## LW 指令
![图 6](../../images/d95aa538482a5c9222fd963e46ae5c124b0b8de1d6e3ad8365d54db1308a4873.png)  


这里我们正好用之前 `sw` 存入内存的数据进行测试，最后再将结果存入内存，释放寄存器。

## BEQ 指令
![图 7](../../images/ca6abc77d78ceb4a2e2f1ef4f9b0df327409af1739060bde266adc9a3b18b23b.png)  


这里把判断成立与不成立的情况都考虑了一遍，最终我们只要看内存中的数据就可以判断 `beq` 指令有没有正确的跳转。

## 结果测试
在我们的程序中，已经把所有有用的数据都存入到了内存中。所以只要将汇编程序对应的二进制码导入到 CPU 中，运行之后查看其内存中的数据，和 Mars 运行结果一比较，我们就可以看出程序有没有错。

# 测试程序的使用
## 说明
本讲将会介绍如何在 **logsim 搭建的 CPU 电路** 和 **使用 Verilog 语言编写的 CPU 工程文件** 中使用测试程序验证 CPU 的正确性。

## LOGSIM 搭建的 CPU 电路
### 1. 准备测试程序
+ 使用 Mars 编写测试程序，以 16 进制格式导出。
+ 在导出的 .txt 文件的首行加上 `v2.0 raw`
+ 文件样例
  ``` js
  v2.0 raw
  3c080001
  35082f6a
  34040004
  34050001
  34060004
  34070020
  ac070000
  8c0a0000
  ac880000
  010a4823
  00862021
  ac850000
  00862021
  00a52821
  ac850000
  00862021
  00a52821
  ac850000
  00862021
  00a52821
  ac850000
  00862021
  00a52821
  ac850000
  00862021
  00a52821
  ac850000
  10e5fff0
  ```
### 2. 导入到 IFU 模块中的 ROM 中

+ IFU 模块中的 ROM 其实就是 IM，用来存储 CPU 将要执行的指令的集合。
+ 导入步骤：

    (1) 选中 ROM 元件，右键 -> Edit Contents

    ![图 8](../../images/f5d4f9dca5686119737f88ecbce96a653b4846b6fb93fecd4f6cacb26442e23f.png)  


    (2) 在弹出的编辑框中点击 Open 导入我们准备好的测试程序。

    ![图 9](../../images/68917ab8679bc05aa2a45f3067259643b41c76f86791255258786593bd587eb3.png)  


### 3. 运行 CPU 电路

+ 选择菜单栏 Simulate -> Ticks Enabled 运行 CPU 电路。
### 4. 检查结果

+ 检查 GPR 模块中各个寄存器的值是否与预期的相同。
+ 检查 DM 模块中内存数据的值是否与预期的相同。
+ 测试程序预期的结果可以使用 Mars 查看。
## VERILOG 语言编写的 CPU 工程文件
### 1.准备测试程序

+ Verilog 编写的 CPU 程序可以直接使用 Mars 导出的 16 进制机器码文件，不需要额外的修改。
### 2.导入到 IM 中
+ 在前期，我们是使用 reg 数组来模拟 ROM 存储指令的，比如 `reg [31:0] im[1023:0]` 就是一个可以存储 1024 条指令的 reg 数组，每个数组元素是 32 位，也就是一条指令的大小，数组下标是 0~1023。
+ 我们向数组中存储数据时使用的是系统函数 `$readmemh`。

    (1) 格式：`$readmemh(“file”, mem_name, start_addr, stop_addr)`

    (2) `file` 是导入的 16 进制测试文件，不使用绝对路径时要将其放在工程文件下。

    (3) `mem_name` 是我们存储元件的名字，这里就是数组的名字 `im`。

    (4) `start_addr` 和 `stop_addr` 是测试文件导入到存储元件中的起始地址和终止地址，在这里就是数组的下标，是可选参数。

  + 样例：`$readmemh("code.txt", im);`
  
    (1) code.txt 是测试文件，im 是 reg 数组名。

    (2)因为 im 数组大小为 4KB，所以提取指令时只需要用到 32 位地址中的前 12 位。相对于我们设置的起始地址 0x0000_3000 而言，前 12 位都是 0，所以指令正好是从数组的首个元素开始存储。因此，这里就不用地址参数了。

### 3.运行 CPU 程序

+ 选中工程文件 -> Simulata Behavioral Modul
### 4.检查结果

+ 在 Isim 界面左侧选择 Memory 选项，即可选择查看 GPR、DM、IM 中的数据。

![图 10](../../images/83b226979b9bdd3dcb058d0e1b766e01dec80e336a734353480832a480abebd2.png)  


