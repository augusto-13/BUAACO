# 整体结构
## 概述
通过 Pre 预习教程、P0、P1 和 P2 的学习，想必你已经基本掌握了本课程工具集的使用，是时候小试牛刀了。在本节中，你将使用 Logisim 开发一个简单的 MIPS 单周期处理器，并使用 Mars 自行编写测试程序，验证 CPU 设计的正确性。本节的实验将带你走进 CPU 的世界，一窥 CPU 内部的构造，为今后更为复杂的实验打下基础。在这个过程中，我们希望同学能够自行阅读理论课本的有关章节以及其他有关资料作为参考，也希望同学们能够认真编写自己的 CPU 设计文档，它是我们进行电路搭建的指南。**值得一提的是，我们将会在课下以及课上测试环节对文档中的内容（设计文档、测试方案与思考题）加以检查，请做好准备！**

## 基本思路
本节中，我们设计的 CPU 将包含 `Controller`（控制器）、`IFU`（取指令单元）、`GRF`（通用寄存器组，也称为寄存器文件、寄存器堆）、`ALU`（算术逻辑单元）、`DM`（数据存储器）、 `EXT`（位扩展器）等基本部件，通过 `MUX`、 `Splitter` 等内置器件组合连接成数据通路。一个可能的顶层设计参考图示为：

![图 1](../../images/fa872223afc9a6f7b92d2cb3e2abbd4fe1c738315a3a43ca2045258218e9ad33.png)  


## 设计与测试说明
+ 处理器为32位处理器。
+ 处理器应支持的指令集为：{addu, subu, ori, lw, sw, beq, lui, nop}。
+ nop 机器码为 0x00000000， 即空指令，不进行任何有效行为（修改寄存器等）。
+ addu，subu 可以不支持溢出。
+ 处理器为 **单周期** 设计。
+ 需要采用 **模块化** 和 **层次化** 设计。顶层有效的驱动信号要求包括且仅包括：**异步复位信号** **reset** **（ clk 请使用内置时钟模块）**。
+ **需自行构造测试集**，验证设计的正确性。（通过课下自动测试 **并不意味** 着你的设计 **完全不存在问题**）。
+ 之后每节说明性内容后都附有 **文档撰写建议** 与 **相关思考题** ，请务必完成相关思考题并附在 CPU 设计文档后！
  + 最后需要提交的内容： CPU 设计文档（含思考题）、 Logisim 电路源文件。
  + 友情提示：请通读本章所有内容后再进行设计，以避免无谓的修改！

# 模块规格
## 模块规格
模块规格是设计文档的重要部分，它包含了 CPU 各个模块的 **端口说明** 与 **功能定义**。一份好的模块规格可以让其他人快速理解该模块的功能并加以实现。这就相当于一份 CPU 重要部件的“说明书”。

在模块规格这个部分我们不直接给出详细的端口说明与功能规定，仅给出简略的要求，希望同学们在使用 Logisim 搭建 CPU 过程中，自行完成相应的设计，**清晰阐明所有模块的功能，并给出关键模块（如 GRF、DM ）的各端口定义及内部逻辑实现** 。在课上测试中，我们将会检查此部分，**请保证你一定能够让其他人理解你的说明**！

下面我们就各个模块给出几点要求：

+ IFU（取指令单元）：内部包括 PC（程序计数器）、IM (指令存储器) 及相关逻辑。

  + PC 用寄存器实现，应具有**异步复位**功能，复位值为起始地址。
  + **起始地址：0x00000000**。
  + IM 用 ROM 实现，容量为 32bit * 32。
  + 因 IM 实际地址宽度仅为 5 位，故需要使用恰当的方法将 PC 中储存的地址同 IM 联系起来。
  
+ GRF（通用寄存器组，也称为寄存器文件、寄存器堆）

  + 用具有写使能的寄存器实现，寄存器总数为 32 个，应具有**异步复位**功能。
  + **0 号寄存器** 的值始终保持为 0。其他寄存器**初始值（复位后）均为 0**，无需专门设置。
+ ALU（算术逻辑单元）

  +  提供 32 位加、减、或运算及大小比较功能。 
  + 可以不支持溢出（不检测溢出）。
+ DM（数据存储器）

  + 使用 RAM 实现，容量为 32bit * 32，应具有异步复位功能，复位值为 0x00000000。
  + 起始地址：0x00000000。
  + RAM 应使用双端口模式，即设置 RAM 的 **Data Interface** 属性为 **Separate load and store ports**。
+ EXT：

  + 可以使用 Logisim 内置的 Bit Extender。
+ Controller（控制器）

  + 使用与或门阵列构造控制信号，
  + 具体方法见后文叙述。
## 文档撰写建议
​ 模块规格部分中，由于控制器较为特殊以及其在 CPU 中的核心地位，建议单独开一章节描述控制器的设计。

## 思考题

```
现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 
请给出分析，若有改进意见也请一并给出。
```

# 控制器设计
## 控制器设计
控制器的设计，从最基本的层面来说，是一个 **译码** 的过程，将每一条机器指令中包含的信息，转化为给 CPU 各部分的控制信号（ RegDst， ALUSrc 等等），相信同学们在理论课上也了解了该部分的内容。而到了实践层面，如何让解码过程变的工程上可实现，是一个重要的问题。最为直接的办法就是生成真值表，但是这样在实际操作中不具有可扩展性与易调试性，指令数增加时非常容易导致 Bug 产生。所以，我们在下面提出一种可行的建议，供同学们参考。

我们把解码逻辑分解为 **和逻辑** 和 **或逻辑** 两部分：和逻辑的功能是 **识别** ，将输入的机器码识别为相应的指令；或逻辑的功能是 **生成** ，根据输入的指令的不同，产生不同的控制信号。这种拆分使得两部分逻辑目的明确，这是一种朴素的 **抽象** 与 **模块化**，希望同学们能够在其他的领域也加以借鉴。（这种思想的集大成者是 UNIX， 感兴趣的同学可以搜索“ UNIX 哲学“加深了解）




而在设计这两套逻辑的过程中，和逻辑是非常自然的。而或逻辑则需要我们建立从指令到控制信号的映射，为了避免错误的产生，我们希望使用真值表来完成相应的设计任务，并希望通过真值表可以简化相应的逻辑。一个典型的真值表如下图：

![图 3](../../images/71dda3034977586071d294a3768d2dcc95be6a13db1dd68b5fb0eb99ccbfac07.png)  


下图是上述逻辑在 Logisim 中的电路具体实现样例—— **与或门阵列**（并不完整），当然你也可以有自己的电路设计，比如使用 Tunnel 来简化布线、对指令进行合理的分类建模等方案。

![图 4](../../images/2c034aaf8053633ae9aa740cf4ed14ed0b09581b983978f1db7c986ac431a618.png)  


## 文档撰写建议
+ 描述控制器的具体电路逻辑，并阐释你如何将控制器设计得更简洁且有条理。
+ 建立一张表来说明各个控制信号的功能。

## 思考题
```
事实上，实现 nop 空指令，
我们并不需要将它加入控制信号真值表，为什么？
```

# 测试 CPU
## 测试 CPU
在完成 CPU 搭建后，进行 CPU 的测试是一个重要的环节，它可以检查出我们 CPU 设计和实现的错误。在 Pre 的 “MIPS 指令集及汇编语言” 部分中，我们简要介绍了测试程序设计的一些要点，而在分析同学们的课下提交时，我们也发现一些测试方面问题，下面将就课下指令功能测试进行一些补充。

### 计算类指令功能测试
+ 寄存器数据方面，可以考虑以下情况：
  + $0$ 及附近的数：$-2, -1, 0, 1, 2$
  + $32$ 位数边界附近的数： $-2147483648, -2147483647, 2147483646, 2147483647$
  + $32$ 位数范围内的一些随机数：$-1000786109, 1919156834, ...$
+ 无符号立即数方面，可以考虑以下情况：
  + $0$ 及附近的数：$0, 1, 2, 3$
  + $16$ 位无符号数边界附近的数：$65533, 65534, 65535$
  + $16$ 位无符号数范围内的一些随机数：$25779, 42528, ...$
+ 符号立即数 (P3 不涉及) 方面，可以考虑以下情况：
  + $0$ 及附近的数：$-2, -1, 0, 1, 2$
  + $16$ 位符号数边界附近的数：$-32768, -32767, 32766, 32767$
  + $16$ 位符号数范围内的一些随机数：$-5329, 25299, ...$
+ 特别的，可注意测试目标寄存器是 $\$0$ 的情况。
  
### 存取类指令功能测试
+ `offset` 方面，可以考虑以下情况：
  + `offset` 是正数
  + `offset` 是零
  + `offset` 是负数
+ $\$base$ 寄存器方面，可以考虑以下情 况：
  + $\$base$ 寄存器中的值是正数
  + $\$base$ 寄存器中的值是零
  + $\$base$ 寄存器中的值是负数
+ 特别的，对于 `sw` 指令，建议存入的 `word` 中，每个 `byte` 都不是零。
+ 特别的，对于 `lw` 指令，可注意测试目标寄存器是 $\$0$ 的情况。
### 跳转类指令功能测试
+ 对于 **非比较相关** 的部分，可以考虑以下情况：
  + 跳转，且目标在此跳转指令之前
  + 跳转，且目标是此跳转指令
  + 跳转，且目标在此跳转指令之后
  + 不跳转，且目标在此跳转指之前
  + 不跳转，且目标是此跳转指令
  + 不跳转，且目标在此跳转指令之后
+ 对于 **比较相关** 的部分，本质上依旧是构造寄存器数据，处理类似 “计算类指令功能测试”。

### 其它测试上的建议
+ 为更方便的进行测试，同学们可以将 IM 调大至 $1024$，以便一次测试执行更多的指令。
+ 为更有效的进行测试，同学们可以在测试程序开始时将 $31$ 个寄存器初始化成非 $0$ 值 (需要配合调大 `IM`)，这往往 **有助于发现 Bug** ，有兴趣的同学可以思考其原因。
+ 在本实验中，我们要求 `PC` 和 `DM` 的起始地址均为 $0$，而 **MARS 是不能够将两者的地址区间设定重叠的**。因此大家可以 **修改生成的指令机器码** ，或者 **对本地的 Logisim 电路进行一些处理** ，来保证测试能够顺利进行，但请注意：

  + 课上测试时，要求起始地址为 0x00000000，因此采用此方式测试时，请保证起始地址 **易于修改，以免课上测试时出现问题。**
  + 课上测试时，要求起始地址为 0x00000000，因此采用此方式测试时，请保证起始地址 **易于修改，以免课上测试时出现问题。**
  + 课上测试时，要求起始地址为 0x00000000，因此采用此方式测试时，请保证起始地址 **易于修改，以免课上测试时出现问题。**
+ 事实上，在现代主流计算机中，数据存储器和指令存储器的起始地址 **不应该重叠** ，但在我们的设计中，由于采用分离存储器设计方案，因此可以暂时忽略这一点。
+ 为验证自己设计的正确性，一种简易且可行的方式是：

  + 对直接产生结果的指令，将结果存入内存，同时增加维护存入内存位置的 “指针”，其逻辑类似以下代码：

    ``` js
    save [index++] = result;
    ```
  + 对于不产生结果的指令，可以通过构造指令序列，使指令执行结果不同时 (如跳转 / 不跳转)，存入内存的值不同或值的数量不同，其逻辑类似以下代码：
    ``` js
    if (branch) save [index++] = result1;
    else save [index++] = result2;
    ```
    ``` js
    if (branch) save [index++]= result;
    save [index++] = result;
    ```
  + 测试程序运行结束后，将 Logisim 中 `DM` 中的内容和 MARS 中内存中的内容导出并比对，由于两者格式不同，同学们可以实现一个用于比对的程序，对于经过程序设计和数据结构训练的同学们而言，这并不难。
  + 使用这种方式时，同学们可以将 `DM` 也调大至 $1024$ 或更多。
  + 此外我们也可以通过其它方式进行正确性验证，同学们可以自行探索。
+ 最后，虽然在实际开发中测试驱动开发是一种可行的模式，但在本课程中测试更多的是一种 “锦上添花”。我们鼓励同学们构造样例进行测试，但请优先保证 **完成处理器本身的设计** 并 **通过课下测试** 。

## 文档撰写建议
请在测试文档中阐述你采用的测试方案，将测试样例分类、有条理地列出 (对于测试样例较多或较长的情况，可只展示关键部分)。如果采用了自动生成程序或开发了较完整的评测系统，需要对这一系统的功能进行描述，并对其使用方法与实现原理进行说明。

## 思考题
```
上文提到，MARS 不能导出 PC 与 DM 起始地址均为 00 的机器码。
实际上，可以通过为 DM 增添片选信号，来避免手工修改的麻烦。
请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。

除了编写程序进行测试外，还有一种验证 CPU 设计正确性的办法 —— 形式验证。
形式验证的含义是根据某个或某些形式规范或属性，使用数学的方法证明其正确性或非正确性。
请搜索 “形式验证 (Formal Verification)”，了解相关内容后，简要阐述相比于测试，形式验证的优劣之处。
```